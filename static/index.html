<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Samisk Transkribering</title>
  <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
  <main class="shell">
    <header class="app-header">
      <div>
        <h1>Samisk transkribering</h1>
        <p>Upload audio or video in one step, then review and download the transcript.</p>
      </div>
    </header>

    <div class="layout">
      <section class="panel panel-upload">
        <div class="panel-body">
          <form id="upload-form" class="upload-form" aria-label="Upload media for transcription">
            <div id="dropzone" class="dropzone" tabindex="0" role="button" aria-describedby="dropzone-help">
              <div class="dropzone-icon" aria-hidden="true">
                <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 17.5V6.5A2.5 2.5 0 0 1 5.5 4h13a2.5 2.5 0 0 1 2.5 2.5v11a2.5 2.5 0 0 1-2.5 2.5h-13A2.5 2.5 0 0 1 3 17.5Z"/>
                  <path d="M12 12v6"/>
                  <path d="M9 15l3-3 3 3"/>
                  <path d="M6 8h12"/>
                </svg>
              </div>
              <p class="dropzone-title">Drag &amp; drop your file</p>
              <p id="dropzone-help" class="dropzone-help">Audio or video up to 2 GB. You can also <span class="dropzone-browse">browse</span> your device.</p>
            </div>
            <input type="file" id="file-input" class="sr-only" accept="audio/*,video/*" required>

            <div id="file-summary" class="file-summary hidden" aria-live="polite"></div>

            <div id="progress-wrapper" class="progress-wrapper hidden" aria-live="polite">
              <div class="progress-block">
                <div class="progress-label">
                  <span id="annotation-progress-label">Annotation &amp; diarization</span>
                  <span id="annotation-progress-value">0%</span>
                </div>
                <div id="annotation-progress-bar" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Annotation progress">
                  <div id="annotation-progress-fill" class="progress-bar__fill"></div>
                  <span id="annotation-progress-text" class="progress-bar__text">0%</span>
                </div>
              </div>
              <div class="progress-block">
                <div class="progress-label">
                  <span id="transcription-progress-label">Transcription</span>
                  <span id="transcription-progress-value">0%</span>
                </div>
                <div id="transcription-progress-bar" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Transcription progress">
                  <div id="transcription-progress-fill" class="progress-bar__fill"></div>
                  <span id="transcription-progress-text" class="progress-bar__text">0%</span>
                </div>
              </div>
              <div id="progress-summary" class="progress-summary" aria-live="polite">Overall 0%</div>
            </div>

            <button type="submit" id="submit-btn" class="button-primary">Start transcription</button>
            <button type="button" id="new-upload-btn" class="button-secondary hidden">Upload another file</button>
          </form>
          <div id="status" class="status" role="status" aria-live="polite"></div>
        </div>
      </section>

      <section id="output-panel" class="panel panel-output hidden" aria-live="polite">
        <div class="panel-body">
          <div class="output-header">
            <div>
              <h2>Transcript</h2>
              <div id="job-status" class="job-status"></div>
            </div>
            <div class="action-buttons">
              <button id="save-btn" class="button-primary" disabled>Save corrections</button>
              <button id="download-btn" class="button-secondary" disabled>Download PDF</button>
            </div>
          </div>
          <div class="editor-wrapper">
            <label class="sr-only" for="transcript-text">Transcript editor</label>
            <textarea id="transcript-text" placeholder="Your transcript will appear here when processing completes." disabled></textarea>
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    const form = document.getElementById('upload-form');
    const fileInput = document.getElementById('file-input');
    const dropzone = document.getElementById('dropzone');
    const fileSummary = document.getElementById('file-summary');
    const statusEl = document.getElementById('status');
    const outputPanel = document.getElementById('output-panel');
    const jobStatusEl = document.getElementById('job-status');
    const transcriptText = document.getElementById('transcript-text');
    const saveBtn = document.getElementById('save-btn');
    const downloadBtn = document.getElementById('download-btn');
    const submitBtn = document.getElementById('submit-btn');
    const progressWrapper = document.getElementById('progress-wrapper');
    const annotationProgressBar = document.getElementById('annotation-progress-bar');
    const annotationProgressFill = document.getElementById('annotation-progress-fill');
    const annotationProgressText = document.getElementById('annotation-progress-text');
    const annotationProgressValue = document.getElementById('annotation-progress-value');
    const transcriptionProgressBar = document.getElementById('transcription-progress-bar');
    const transcriptionProgressFill = document.getElementById('transcription-progress-fill');
    const transcriptionProgressText = document.getElementById('transcription-progress-text');
    const transcriptionProgressValue = document.getElementById('transcription-progress-value');
    const progressSummary = document.getElementById('progress-summary');
    const newUploadBtn = document.getElementById('new-upload-btn');

    let currentJobId = null;
    let pollTimer = null;
    let selectedFile = null;
    let currentPhase = null;
    let lastProgress = { annotation: 0, transcription: 0, overall: 0 };

    function clampPercent(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return 0;
      }
      return Math.max(0, Math.min(100, value));
    }

    function updateProgressBars(annotation, transcription) {
      const annotationValue = Math.round(clampPercent(annotation));
      annotationProgressBar.setAttribute('aria-valuenow', String(annotationValue));
      annotationProgressFill.style.width = `${annotationValue}%`;
      annotationProgressText.textContent = `${annotationValue}%`;
      annotationProgressValue.textContent = `${annotationValue}%`;

      const transcriptionValue = Math.round(clampPercent(transcription));
      transcriptionProgressBar.setAttribute('aria-valuenow', String(transcriptionValue));
      transcriptionProgressFill.style.width = `${transcriptionValue}%`;
      transcriptionProgressText.textContent = `${transcriptionValue}%`;
      transcriptionProgressValue.textContent = `${transcriptionValue}%`;

      const overallValue = Math.round((annotationValue + transcriptionValue) / 2);
      if (progressSummary) {
        progressSummary.textContent = `Overall ${overallValue}%`;
      }

      lastProgress = {
        annotation: annotationValue,
        transcription: transcriptionValue,
        overall: overallValue,
      };

      return lastProgress;
    }

    function renderJobStatus(status, progressSnapshot, currentTask) {
      const phase = status || currentTask || 'pending';
      const annotationPercent = progressSnapshot.annotation ?? 0;
      const transcriptionPercent = progressSnapshot.transcription ?? 0;
      const overallPercent = progressSnapshot.overall ?? 0;
      const task = (currentTask || '').toLowerCase();

      switch (phase) {
        case 'pending':
        case 'queued':
          return 'Waiting for worker…';
        case 'diarizing':
          if (task.includes('chunking')) {
            return `Sentence chunking ${annotationPercent}% complete · Overall ${overallPercent}%`;
          }
          if (task.includes('speaker')) {
            return `Speaker diarization ${annotationPercent}% complete · Overall ${overallPercent}%`;
          }
          return `Annotation ${annotationPercent}% complete · Overall ${overallPercent}%`;
        case 'transcribing':
        case 'processing':
          return `Transcription ${transcriptionPercent}% complete · Overall ${overallPercent}%`;
        case 'completed':
          return 'Transcription complete.';
        case 'failed':
          return 'Transcription failed.';
        default:
          return phase;
      }
    }

    function applyJobUpdate(job) {
      if (!job) {
        return updateProgressBars(0, 0);
      }

      const annotation = Number(job.progress?.annotation ?? 0);
      const transcription = Number(job.progress?.transcription ?? 0);

      const snapshot = updateProgressBars(annotation, transcription);
      jobStatusEl.textContent = renderJobStatus(job.status, snapshot, job.current_task);

      if (job.status) {
        setPhase(job.status);
      }

      return snapshot;
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      if (!bytes) return '';
      const units = ['B', 'KB', 'MB', 'GB'];
      const exponent = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
      const value = bytes / Math.pow(1024, exponent);
      return `${value.toFixed(value >= 10 || exponent === 0 ? 0 : 1)} ${units[exponent]}`;
    }

    function setStatus(message, type = '') {
      statusEl.textContent = message;
      statusEl.className = `status${type ? ` status--${type}` : ''}`;
    }

    function resetOutput() {
      outputPanel.classList.add('hidden');
      jobStatusEl.textContent = '';
      transcriptText.value = '';
      transcriptText.disabled = true;
      saveBtn.disabled = true;
      downloadBtn.disabled = true;
      currentJobId = null;
      if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
      }
    }

    function showDropzone() {
      dropzone.classList.remove('hidden');
      dropzone.setAttribute('aria-hidden', 'false');
    }

    function hideDropzone() {
      dropzone.classList.add('hidden');
      dropzone.setAttribute('aria-hidden', 'true');
    }

    function setSubmitButton(label, disabled) {
      submitBtn.textContent = label;
      submitBtn.disabled = disabled;
    }

    function setPhase(phase) {
      const resolved = phase || 'idle';
      if (resolved === currentPhase) {
        return;
      }

      currentPhase = resolved;

      switch (resolved) {
        case 'idle':
          updateProgressBars(0, 0);
          progressWrapper.classList.add('hidden');
          showDropzone();
          jobStatusEl.textContent = '';
          setSubmitButton('Start transcription', false);
          newUploadBtn.classList.add('hidden');
          break;
        case 'uploading':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          updateProgressBars(0, 0);
          setSubmitButton('Uploading…', true);
          newUploadBtn.classList.add('hidden');
          break;
        case 'pending':
        case 'queued':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Processing…', true);
          newUploadBtn.classList.add('hidden');
          break;
        case 'diarizing':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Processing…', true);
          newUploadBtn.classList.add('hidden');
          break;
        case 'transcribing':
        case 'processing':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Processing…', true);
          newUploadBtn.classList.add('hidden');
          break;
        case 'completed':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Transcription complete', true);
          newUploadBtn.classList.remove('hidden');
          break;
        case 'failed':
          showDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Start transcription', false);
          newUploadBtn.classList.remove('hidden');
          break;
        default:
          break;
      }
    }

    setPhase('idle');

    function updateSelectedFile(file) {
      selectedFile = file || null;
      if (!file) {
        fileSummary.textContent = '';
        fileSummary.classList.add('hidden');
        setPhase('idle');
        return;
      }

      fileSummary.innerHTML = '';
      const nameEl = document.createElement('strong');
      nameEl.textContent = file.name;
      const metaEl = document.createElement('span');
      const fileType = file.type || 'Unknown type';
      metaEl.textContent = `${fileType} · ${formatBytes(file.size)}`;
      fileSummary.appendChild(nameEl);
      fileSummary.appendChild(metaEl);
      fileSummary.classList.remove('hidden');
      setStatus('Ready to upload.', 'info');
    }

    function activateDropzone() {
      dropzone.classList.add('dropzone--active');
    }

    function deactivateDropzone() {
      dropzone.classList.remove('dropzone--active');
    }

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        fileInput.click();
      }
    });

    ['dragenter', 'dragover'].forEach((eventName) => {
      dropzone.addEventListener(eventName, (event) => {
        event.preventDefault();
        activateDropzone();
        event.dataTransfer.dropEffect = 'copy';
      });
    });

    ['dragleave', 'dragend'].forEach((eventName) => {
      dropzone.addEventListener(eventName, () => {
        deactivateDropzone();
      });
    });

    dropzone.addEventListener('drop', (event) => {
      event.preventDefault();
      deactivateDropzone();
      const file = event.dataTransfer?.files?.[0];
      if (!file) {
        return;
      }
      const allowed = file.type.startsWith('audio/') || file.type.startsWith('video/');
      if (!allowed) {
        setStatus('Unsupported file type. Please choose audio or video.', 'error');
        return;
      }
      try {
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(file);
        fileInput.files = dataTransfer.files;
      } catch (assignError) {
        // Fallback for browsers without DataTransfer constructor support.
      }
      updateSelectedFile(file);
      resetOutput();
    });

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files?.[0];
      updateSelectedFile(file || null);
      resetOutput();
    });

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const file = fileInput.files?.[0] || selectedFile;
      if (!file) {
        setStatus('Please choose a file first.', 'error');
        return;
      }

      const formData = new FormData();
      formData.append('file', file);
      setStatus('Uploading file…', 'info');
      resetOutput();
      setPhase('uploading');

      try {
        const response = await fetch('/api/transcriptions', {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          let errorMessage = 'Upload failed';
          try {
            const error = await response.json();
            errorMessage = error.detail || errorMessage;
          } catch (parseError) {
            // Ignore JSON parse errors; fall back to default message.
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        currentJobId = data.job_id;
        outputPanel.classList.remove('hidden');
        transcriptText.value = '';
        transcriptText.disabled = true;
        setStatus('File uploaded. Transcription started.', 'success');
        applyJobUpdate(data);
        startPolling();
      } catch (error) {
        console.error(error);
        setStatus(error.message || 'Upload failed', 'error');
        setPhase('failed');
      }
    });

    function startPolling() {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(async () => {
        if (!currentJobId) return;
        try {
          const response = await fetch(`/api/transcriptions/${currentJobId}`);
          if (!response.ok) {
            throw new Error('Failed to retrieve job status');
          }
          const data = await response.json();
          applyJobUpdate(data);

          if (data.status === 'completed') {
            clearInterval(pollTimer);
            pollTimer = null;
            transcriptText.value = data.text || '';
            transcriptText.disabled = false;
            transcriptText.focus({ preventScroll: true });
            saveBtn.disabled = false;
            downloadBtn.disabled = false;
            setStatus('Transcription complete. Review and correct as needed.', 'success');
            setPhase('completed');
          } else if (data.status === 'failed') {
            clearInterval(pollTimer);
            pollTimer = null;
            transcriptText.disabled = true;
            setStatus(`Transcription failed: ${data.error || 'Unknown error'}`, 'error');
            setPhase('failed');
          }
        } catch (error) {
          console.error(error);
        }
      }, 3000);
    }

    saveBtn.addEventListener('click', async () => {
      if (!currentJobId) return;
      saveBtn.disabled = true;
      setStatus('Saving corrections…', 'info');
      try {
        const response = await fetch(`/api/transcriptions/${currentJobId}/finalise`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: transcriptText.value }),
        });
        if (!response.ok) {
          let errorMessage = 'Failed to save corrections';
          try {
            const error = await response.json();
            errorMessage = error.detail || errorMessage;
          } catch (parseError) {
            // Ignore JSON parse errors; fall back to default message.
          }
          throw new Error(errorMessage);
        }
        setStatus('Corrections saved.', 'success');
        downloadBtn.disabled = false;
      } catch (error) {
        console.error(error);
        setStatus(error.message || 'Failed to save corrections', 'error');
      } finally {
        saveBtn.disabled = false;
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (!currentJobId) return;
      window.open(`/api/transcriptions/${currentJobId}/download`, '_blank');
    });

    newUploadBtn.addEventListener('click', () => {
      fileInput.value = '';
      selectedFile = null;
      fileSummary.textContent = '';
      fileSummary.classList.add('hidden');
      setStatus('', '');
      setPhase('idle');
      currentJobId = null;
    });
  </script>
</body>
</html>
