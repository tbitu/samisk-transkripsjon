<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Samisk Transkribering</title>
  <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
  <main class="shell">
    <header class="app-header">
      <div>
        <h1>Samisk transkribering</h1>
        <p>Upload audio or video in one step, then review and download the transcript.</p>
      </div>
    </header>

    <!-- Server Busy Panel -->
    <div id="server-busy-panel" class="panel panel-busy hidden" aria-live="polite">
      <div class="panel-body">
        <div class="busy-content">
          <div class="busy-icon" aria-hidden="true">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"/>
              <polyline points="12 6 12 12 16 14"/>
            </svg>
          </div>
          <h2>Server Busy</h2>
          <p id="busy-message">Another transcription is currently in progress.</p>
          <div class="progress-block">
            <div class="progress-label">
              <span id="busy-step-label">Processing</span>
              <span id="busy-progress-value">0%</span>
            </div>
            <div id="busy-progress-bar" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Server progress">
              <div id="busy-progress-fill" class="progress-bar__fill"></div>
              <span id="busy-progress-text" class="progress-bar__text">0%</span>
            </div>
          </div>
          <p id="busy-time-estimate" class="busy-time-estimate"></p>
          <button id="refresh-btn" class="button-secondary">Check Again</button>
        </div>
      </div>
    </div>

    <div class="layout">
      <section class="panel panel-upload">
        <div class="panel-body">
          <form id="upload-form" class="upload-form" aria-label="Upload media for transcription">
            <div id="dropzone" class="dropzone" tabindex="0" role="button" aria-describedby="dropzone-help">
              <div class="dropzone-icon" aria-hidden="true">
                <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 17.5V6.5A2.5 2.5 0 0 1 5.5 4h13a2.5 2.5 0 0 1 2.5 2.5v11a2.5 2.5 0 0 1-2.5 2.5h-13A2.5 2.5 0 0 1 3 17.5Z"/>
                  <path d="M12 12v6"/>
                  <path d="M9 15l3-3 3 3"/>
                  <path d="M6 8h12"/>
                </svg>
              </div>
              <p class="dropzone-title">Drag &amp; drop your file</p>
              <p id="dropzone-help" class="dropzone-help">Audio or video up to 2 GB. You can also <span class="dropzone-browse">browse</span> your device.</p>
            </div>
            <input type="file" id="file-input" class="sr-only" accept="audio/*,video/*" required>

            <div id="file-summary" class="file-summary hidden" aria-live="polite"></div>

            <div id="progress-wrapper" class="progress-wrapper hidden" aria-live="polite">
              <div class="progress-block">
                <div class="progress-label">
                  <span id="current-step-label">Current Task</span>
                  <span id="current-step-value">0%</span>
                </div>
                <div id="current-step-bar" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Current task progress">
                  <div id="current-step-fill" class="progress-bar__fill"></div>
                  <span id="current-step-text" class="progress-bar__text">0%</span>
                </div>
              </div>
              <div class="progress-block">
                <div class="progress-label">
                  <span id="overall-progress-label">Overall Progress</span>
                  <span id="overall-progress-value">0%</span>
                </div>
                <div id="overall-progress-bar" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Overall progress">
                  <div id="overall-progress-fill" class="progress-bar__fill"></div>
                  <span id="overall-progress-text" class="progress-bar__text">0%</span>
                </div>
              </div>
            </div>

            <button type="submit" id="submit-btn" class="button-primary">Start transcription</button>
            <button type="button" id="new-upload-btn" class="button-secondary hidden">Upload another file</button>
          </form>
          <div id="status" class="status" role="status" aria-live="polite"></div>
        </div>
      </section>

      <section id="output-panel" class="panel panel-output hidden" aria-live="polite">
        <div class="panel-body">
          <div class="output-header">
            <div>
              <h2>Transcript</h2>
            </div>
            <div class="action-buttons">
              <button id="save-btn" class="button-primary" disabled>Save corrections</button>
              <button id="download-btn" class="button-secondary" disabled>Download PDF</button>
            </div>
          </div>
          <div class="editor-wrapper">
            <label class="sr-only" for="transcript-text">Transcript editor</label>
            <textarea id="transcript-text" placeholder="Your transcript will appear here when processing completes." disabled></textarea>
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    const form = document.getElementById('upload-form');
    const fileInput = document.getElementById('file-input');
    const dropzone = document.getElementById('dropzone');
    const fileSummary = document.getElementById('file-summary');
    const statusEl = document.getElementById('status');
    const outputPanel = document.getElementById('output-panel');
    const transcriptText = document.getElementById('transcript-text');
    const saveBtn = document.getElementById('save-btn');
    const downloadBtn = document.getElementById('download-btn');
    const submitBtn = document.getElementById('submit-btn');
    const progressWrapper = document.getElementById('progress-wrapper');
    const currentStepBar = document.getElementById('current-step-bar');
    const currentStepFill = document.getElementById('current-step-fill');
    const currentStepText = document.getElementById('current-step-text');
    const currentStepValue = document.getElementById('current-step-value');
    const currentStepLabel = document.getElementById('current-step-label');
    const overallProgressBar = document.getElementById('overall-progress-bar');
    const overallProgressFill = document.getElementById('overall-progress-fill');
    const overallProgressText = document.getElementById('overall-progress-text');
    const overallProgressValue = document.getElementById('overall-progress-value');
    const newUploadBtn = document.getElementById('new-upload-btn');
    const serverBusyPanel = document.getElementById('server-busy-panel');
    const busyMessage = document.getElementById('busy-message');
    const busyStepLabel = document.getElementById('busy-step-label');
    const busyProgressValue = document.getElementById('busy-progress-value');
    const busyProgressBar = document.getElementById('busy-progress-bar');
    const busyProgressFill = document.getElementById('busy-progress-fill');
    const busyProgressText = document.getElementById('busy-progress-text');
    const busyTimeEstimate = document.getElementById('busy-time-estimate');
    const refreshBtn = document.getElementById('refresh-btn');

    let currentJobId = null;
    let currentSessionId = null;
    let pollTimer = null;
    let busyPollTimer = null;
    let selectedFile = null;
    let currentPhase = null;
    let lastProgress = { step: 0, overall: 0, stepName: 'Starting' };

    // Session management
    const SESSION_KEY = 'samisk_transcription_session';
    const SESSION_ID_KEY = 'samisk_session_id';

    function saveSession(jobId, sessionId) {
      if (jobId) {
        localStorage.setItem(SESSION_KEY, jobId);
      }
      if (sessionId) {
        localStorage.setItem(SESSION_ID_KEY, sessionId);
      }
    }

    function loadSession() {
      return {
        jobId: localStorage.getItem(SESSION_KEY),
        sessionId: localStorage.getItem(SESSION_ID_KEY)
      };
    }

    function clearSession() {
      localStorage.removeItem(SESSION_KEY);
      localStorage.removeItem(SESSION_ID_KEY);
      currentSessionId = null;
    }

    function formatTimeRemaining(seconds) {
      if (!seconds || seconds < 0) return '';
      
      const mins = Math.ceil(seconds / 60);
      if (mins < 2) return 'Less than a minute remaining';
      if (mins < 60) return `Approximately ${mins} minutes remaining`;
      
      const hours = Math.floor(mins / 60);
      const remainingMins = mins % 60;
      if (remainingMins === 0) return `Approximately ${hours} hour${hours > 1 ? 's' : ''} remaining`;
      return `Approximately ${hours} hour${hours > 1 ? 's' : ''} and ${remainingMins} minutes remaining`;
    }

    function showServerBusy(activeJob) {
      serverBusyPanel.classList.remove('hidden');
      document.querySelector('.layout').classList.add('hidden');
      
      const progress = Math.round(clampPercent(activeJob.progress?.overall || 0));
      busyProgressBar.setAttribute('aria-valuenow', String(progress));
      busyProgressFill.style.width = `${progress}%`;
      busyProgressText.textContent = `${progress}%`;
      busyProgressValue.textContent = `${progress}%`;
      
      const stepName = activeJob.current_step || 'Processing';
      busyStepLabel.textContent = stepName;
      
      if (activeJob.estimated_time_remaining) {
        busyTimeEstimate.textContent = formatTimeRemaining(activeJob.estimated_time_remaining);
      } else {
        busyTimeEstimate.textContent = 'Calculating time estimate...';
      }
      
      // Start polling server status
      if (busyPollTimer) clearInterval(busyPollTimer);
      busyPollTimer = setInterval(checkServerStatus, 5000);
    }

    function hideServerBusy() {
      serverBusyPanel.classList.add('hidden');
      document.querySelector('.layout').classList.remove('hidden');
      if (busyPollTimer) {
        clearInterval(busyPollTimer);
        busyPollTimer = null;
      }
    }

    async function checkServerStatus() {
      try {
        const response = await fetch('/api/transcriptions/status');
        if (!response.ok) return;
        
        const data = await response.json();
        
        if (data.busy && data.active_job) {
          showServerBusy(data.active_job);
        } else {
          hideServerBusy();
        }
      } catch (error) {
        console.error('Failed to check server status:', error);
      }
    }

    function clampPercent(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return 0;
      }
      return Math.max(0, Math.min(100, value));
    }

    function updateProgressBars(stepProgress, overallProgress, stepName) {
      const stepValue = Math.round(clampPercent(stepProgress));
      currentStepBar.setAttribute('aria-valuenow', String(stepValue));
      currentStepFill.style.width = `${stepValue}%`;
      currentStepText.textContent = `${stepValue}%`;
      currentStepValue.textContent = `${stepValue}%`;

      const overallValue = Math.round(clampPercent(overallProgress));
      overallProgressBar.setAttribute('aria-valuenow', String(overallValue));
      overallProgressFill.style.width = `${overallValue}%`;
      overallProgressText.textContent = `${overallValue}%`;
      overallProgressValue.textContent = `${overallValue}%`;

      // Update the step name label
      const displayStepName = stepName || 'Processing';
      currentStepLabel.textContent = displayStepName;

      lastProgress = {
        step: stepValue,
        overall: overallValue,
        stepName: displayStepName,
      };

      return lastProgress;
    }

    function renderJobStatus(status, progressSnapshot, currentStep) {
      const phase = status || 'pending';
      const overallPercent = progressSnapshot.overall ?? 0;
      const stepName = progressSnapshot.stepName || currentStep || 'Starting';

      switch (phase) {
        case 'pending':
        case 'queued':
          return 'Waiting for worker…';
        case 'processing':
          return `${stepName} · Overall ${overallPercent}%`;
        case 'completed':
          return 'Transcription complete.';
        case 'failed':
          return 'Transcription failed.';
        default:
          return `${stepName} · Overall ${overallPercent}%`;
      }
    }

    function applyJobUpdate(job) {
      if (!job) {
        return updateProgressBars(0, 0, 'Starting');
      }

      const stepProgress = Number(job.progress?.step ?? 0);
      const overallProgress = Number(job.progress?.overall ?? 0);
      const stepName = job.current_step || 'Starting';

      const snapshot = updateProgressBars(stepProgress, overallProgress, stepName);

      if (job.status) {
        setPhase(job.status);
      }

      return snapshot;
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      if (!bytes) return '';
      const units = ['B', 'KB', 'MB', 'GB'];
      const exponent = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
      const value = bytes / Math.pow(1024, exponent);
      return `${value.toFixed(value >= 10 || exponent === 0 ? 0 : 1)} ${units[exponent]}`;
    }

    function setStatus(message, type = '') {
      statusEl.textContent = message;
      statusEl.className = `status${type ? ` status--${type}` : ''}`;
    }

    function resetOutput() {
      outputPanel.classList.add('hidden');
      transcriptText.value = '';
      transcriptText.disabled = true;
      saveBtn.disabled = true;
      downloadBtn.disabled = true;
      currentJobId = null;
      if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
      }
    }

    function showDropzone() {
      dropzone.classList.remove('hidden');
      dropzone.setAttribute('aria-hidden', 'false');
    }

    function hideDropzone() {
      dropzone.classList.add('hidden');
      dropzone.setAttribute('aria-hidden', 'true');
    }

    function setSubmitButton(label, disabled) {
      submitBtn.textContent = label;
      submitBtn.disabled = disabled;
    }

    function setPhase(phase) {
      const resolved = phase || 'idle';
      if (resolved === currentPhase) {
        return;
      }

      currentPhase = resolved;

      switch (resolved) {
        case 'idle':
          updateProgressBars(0, 0, 'Starting');
          progressWrapper.classList.add('hidden');
          showDropzone();
          setSubmitButton('Start transcription', false);
          newUploadBtn.classList.add('hidden');
          break;
        case 'uploading':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          updateProgressBars(0, 0, 'Uploading');
          setSubmitButton('Uploading…', true);
          newUploadBtn.classList.add('hidden');
          break;
        case 'pending':
        case 'queued':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Processing…', true);
          newUploadBtn.classList.add('hidden');
          break;
        case 'processing':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Processing…', true);
          newUploadBtn.classList.add('hidden');
          break;
        case 'completed':
          hideDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Transcription complete', true);
          newUploadBtn.classList.remove('hidden');
          break;
        case 'failed':
          showDropzone();
          progressWrapper.classList.remove('hidden');
          setSubmitButton('Start transcription', false);
          newUploadBtn.classList.remove('hidden');
          break;
        default:
          break;
      }
    }

    setPhase('idle');

    function updateSelectedFile(file) {
      selectedFile = file || null;
      if (!file) {
        fileSummary.textContent = '';
        fileSummary.classList.add('hidden');
        setPhase('idle');
        return;
      }

      fileSummary.innerHTML = '';
      const nameEl = document.createElement('strong');
      nameEl.textContent = file.name;
      const metaEl = document.createElement('span');
      const fileType = file.type || 'Unknown type';
      metaEl.textContent = `${fileType} · ${formatBytes(file.size)}`;
      fileSummary.appendChild(nameEl);
      fileSummary.appendChild(metaEl);
      fileSummary.classList.remove('hidden');
      setStatus('Ready to upload.', 'info');
    }

    function activateDropzone() {
      dropzone.classList.add('dropzone--active');
    }

    function deactivateDropzone() {
      dropzone.classList.remove('dropzone--active');
    }

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        fileInput.click();
      }
    });

    ['dragenter', 'dragover'].forEach((eventName) => {
      dropzone.addEventListener(eventName, (event) => {
        event.preventDefault();
        activateDropzone();
        event.dataTransfer.dropEffect = 'copy';
      });
    });

    ['dragleave', 'dragend'].forEach((eventName) => {
      dropzone.addEventListener(eventName, () => {
        deactivateDropzone();
      });
    });

    dropzone.addEventListener('drop', (event) => {
      event.preventDefault();
      deactivateDropzone();
      const file = event.dataTransfer?.files?.[0];
      if (!file) {
        return;
      }
      const allowed = file.type.startsWith('audio/') || file.type.startsWith('video/');
      if (!allowed) {
        setStatus('Unsupported file type. Please choose audio or video.', 'error');
        return;
      }
      try {
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(file);
        fileInput.files = dataTransfer.files;
      } catch (assignError) {
        // Fallback for browsers without DataTransfer constructor support.
      }
      updateSelectedFile(file);
      resetOutput();
    });

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files?.[0];
      updateSelectedFile(file || null);
      resetOutput();
    });

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const file = fileInput.files?.[0] || selectedFile;
      if (!file) {
        setStatus('Please choose a file first.', 'error');
        return;
      }

      const formData = new FormData();
      formData.append('file', file);
      setStatus('Uploading file…', 'info');
      resetOutput();
      setPhase('uploading');

      try {
        const response = await fetch('/api/transcriptions', {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          let errorMessage = 'Upload failed';
          try {
            const error = await response.json();
            errorMessage = error.detail || errorMessage;
          } catch (parseError) {
            // Ignore JSON parse errors; fall back to default message.
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        currentJobId = data.job_id;
        currentSessionId = data.session_id;
        saveSession(currentJobId, currentSessionId);
        outputPanel.classList.remove('hidden');
        transcriptText.value = '';
        transcriptText.disabled = true;
        setStatus('File uploaded. Transcription started.', 'success');
        applyJobUpdate(data);
        startPolling();
      } catch (error) {
        console.error(error);
        setStatus(error.message || 'Upload failed', 'error');
        setPhase('failed');
      }
    });

    function startPolling() {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(async () => {
        if (!currentJobId) return;
        try {
          const headers = {};
          if (currentSessionId) {
            headers['X-Session-Id'] = currentSessionId;
          }
          const response = await fetch(`/api/transcriptions/${currentJobId}`, { headers });
          if (!response.ok) {
            throw new Error('Failed to retrieve job status');
          }
          const data = await response.json();
          applyJobUpdate(data);

          if (data.status === 'completed') {
            clearInterval(pollTimer);
            pollTimer = null;
            transcriptText.value = data.text || '';
            transcriptText.disabled = false;
            transcriptText.focus({ preventScroll: true });
            saveBtn.disabled = false;
            downloadBtn.disabled = false;
            setStatus('Transcription complete. Review and correct as needed.', 'success');
            setPhase('completed');
          } else if (data.status === 'failed') {
            clearInterval(pollTimer);
            pollTimer = null;
            transcriptText.disabled = true;
            setStatus(`Transcription failed: ${data.error || 'Unknown error'}`, 'error');
            setPhase('failed');
          }
        } catch (error) {
          console.error(error);
        }
      }, 3000);
    }

    saveBtn.addEventListener('click', async () => {
      if (!currentJobId) return;
      saveBtn.disabled = true;
      setStatus('Saving corrections…', 'info');
      try {
        const headers = { 'Content-Type': 'application/json' };
        if (currentSessionId) {
          headers['X-Session-Id'] = currentSessionId;
        }
        const response = await fetch(`/api/transcriptions/${currentJobId}/finalise`, {
          method: 'POST',
          headers,
          body: JSON.stringify({ text: transcriptText.value }),
        });
        if (!response.ok) {
          let errorMessage = 'Failed to save corrections';
          try {
            const error = await response.json();
            errorMessage = error.detail || errorMessage;
          } catch (parseError) {
            // Ignore JSON parse errors; fall back to default message.
          }
          throw new Error(errorMessage);
        }
        setStatus('Corrections saved.', 'success');
        downloadBtn.disabled = false;
      } catch (error) {
        console.error(error);
        setStatus(error.message || 'Failed to save corrections', 'error');
      } finally {
        saveBtn.disabled = false;
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (!currentJobId || !currentSessionId) return;
      // Create a temporary link with session ID as query param for download
      const url = `/api/transcriptions/${currentJobId}/download`;
      const a = document.createElement('a');
      a.href = url;
      a.download = '';
      // Add session ID via fetch and blob for authenticated download
      fetch(url, {
        headers: { 'X-Session-Id': currentSessionId }
      })
      .then(response => response.blob())
      .then(blob => {
        const blobUrl = URL.createObjectURL(blob);
        a.href = blobUrl;
        a.click();
        URL.revokeObjectURL(blobUrl);
      })
      .catch(error => {
        console.error('Download failed:', error);
        setStatus('Download failed', 'error');
      });
    });

    newUploadBtn.addEventListener('click', () => {
      fileInput.value = '';
      selectedFile = null;
      fileSummary.textContent = '';
      fileSummary.classList.add('hidden');
      setStatus('', '');
      setPhase('idle');
      currentJobId = null;
      clearSession();
    });

    refreshBtn.addEventListener('click', async () => {
      await checkServerStatus();
    });

    // Restore session on page load
    async function restoreSession() {
      const session = loadSession();
      if (!session.jobId) {
        // No saved job, check if server is busy
        await checkServerStatus();
        return;
      }

      currentSessionId = session.sessionId;

      try {
        const headers = {};
        if (currentSessionId) {
          headers['X-Session-Id'] = currentSessionId;
        }
        const response = await fetch(`/api/transcriptions/${session.jobId}`, { headers });
        if (!response.ok) {
          // Job not found or server error - clear invalid session
          clearSession();
          await checkServerStatus();
          return;
        }

        const job = await response.json();
        currentJobId = session.jobId;
        outputPanel.classList.remove('hidden');
        
        applyJobUpdate(job);

        if (job.status === 'completed') {
          transcriptText.value = job.text || '';
          transcriptText.disabled = false;
          saveBtn.disabled = false;
          downloadBtn.disabled = false;
          setStatus('Welcome back! Your transcription is complete.', 'success');
          setPhase('completed');
        } else if (job.status === 'failed') {
          transcriptText.disabled = true;
          setStatus(`Transcription failed: ${job.error || 'Unknown error'}`, 'error');
          setPhase('failed');
        } else {
          // Still processing or pending
          transcriptText.disabled = true;
          setStatus('Resuming your transcription session...', 'info');
          startPolling();
        }
      } catch (error) {
        console.error('Failed to restore session:', error);
        clearSession();
      }
    }

    // Initialize session restoration when page loads
    (async function init() {
      // First check if server is busy
      const statusResponse = await fetch('/api/transcriptions/status').catch(() => null);
      if (statusResponse?.ok) {
        const statusData = await statusResponse.json();
        
        // Check if we have a saved session
        const session = loadSession();
        
        if (statusData.busy && statusData.active_job) {
          // Server is busy - check if it's our job
          if (session.jobId && session.jobId === statusData.active_job.job_id) {
            // It's our job, restore normally
            await restoreSession();
          } else {
            // Different job is running, show busy screen
            showServerBusy(statusData.active_job);
          }
        } else {
          // Server not busy, restore session if any
          await restoreSession();
        }
      } else {
        // Fallback if status check fails
        await restoreSession();
      }
    })();
  </script>
</body>
</html>
